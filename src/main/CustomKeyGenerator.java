package main;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Random;

/**
 * CustomKeyGenerator class is used to generate 4 types of secure keys,
 * going from lowest to the most secure method.
 */
public class CustomKeyGenerator {
    private static final String REGEX_EXPRESSION = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$";
    private static final Random random = new Random();
    private static final SecureRandom secureRandom = new SecureRandom();
    /**
     * The Java Random class is a Pseudo-Random Number Generator (PRNG),
     * also known as Deterministic Random Number Generator (DRNG).
     * This means it's not truly random.
     * The sequence of random numbers in a PRNG can be completely determined based on its seed.
     * Java doesn't recommend using Random for cryptographic applications.
     * <p>
     * With that said, NEVER use Random for generating keys.
     *
     * @param cipher  {@link String}
     * @param keySize {@link Integer}
     * @return {@link Key}
     */
    protected Key getRandomKey(String cipher, int keySize) {
        byte[] randomKeyBytes = new byte[keySize / 8];
        random.nextBytes(randomKeyBytes);
        return new SecretKeySpec(randomKeyBytes, cipher);
    }

    /**
     * We instantiate a byte array of the desired key size.
     * Now, instead of using Random, we use SecureRandom to generate the random bytes for our byte array.
     * SecureRandom is recommended by Java for generating a random number for cryptographic applications.
     * It minimally complies with FIPS 140-2, Security Requirements for Cryptographic Modules.
     * <p>
     * Clearly, in Java, SecureRandom is the de-facto standard for obtaining randomness.
     *
     * @param cipher  {@link String}
     * @param keySize {@link Integer}
     * @return {@link Key}
     */
    protected Key getSecureRandomKey(String cipher, int keySize) {
        byte[] secureRandomKeyBytes = new byte[keySize / 8];
        secureRandom.nextBytes(secureRandomKeyBytes);
        return new SecretKeySpec(secureRandomKeyBytes, cipher);
    }

    /**
     * We instantiate the CustomKeyGenerator class.
     * Now, instead of using Random or SecureRandom, to generate the key,
     * we are going to use the getKeyFromKeyGenerator() method.
     * It takes in our cipher and preferred key size and generates our Key.
     * <p>
     * <p>
     * So, how's it different from the Random and SecureRandom approaches?
     * There are two crucial differences worth highlighting.
     * <p>
     * For one, neither the Random nor SecureRandom approach
     * can tell whether we're generating keys of the right sizes as per the Cipher specification.
     * It's only when we go for encryption that we'll encounter exceptions if the keys are of an unsupported size.
     * Using SecureRandom with invalid keySize throws an exception when we initialize the cipher for encryption.
     * Using CustomKeyGenerator, on the other hand, fails during key generation itself,
     * allowing us to handle it more appropriately
     *
     * @param cipher  {@link String}
     * @param keySize {@link Integer}
     * @return {@link Key}
     */
    protected static Key getKeyFromKeyGenerator(String cipher, int keySize) throws NoSuchAlgorithmException{
        KeyGenerator keyGenerator = KeyGenerator.getInstance(cipher);
        keyGenerator.init(keySize);
        return keyGenerator.generateKey();
    }
    public Key getKeyFromKG(String cipher, int keySize) {
        try {
            return getKeyFromKeyGenerator(cipher, keySize);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * We've been generating keys from random and not-so-human-friendly byte arrays.
     * Password-Based Key (PBK) offers us the ability to generate a SecretKey based on a human-readable password
     *<p>
     * A user-friendly password doesn't have enough entropy.
     * Hence, we add additional randomly generated bytes called a salt to make it harder to guess.
     * The minimum salt length should be 128 bits. We used SecureRandom to generate our salt.
     * The salt isn't a secret and is stored as plaintext.
     * We should generate salt in pairs with each password and not use the same salt globally.
     * This will protect from Rainbow Table attacks,
     * which use lookups from a precomputed hash table for cracking the passwords.
     * </p>
     * <p>
     * The iteration count is the number of times the secret generation algorithm applies the transformation function.
     * It should be as large as feasible. The minimum recommended iteration count is 1,000.
     * A higher iteration count increases the complexity for the attacker while performing
     * a brute-force check for all possible passwords.
     * The key size is the same we discussed earlier, which can be 128, 192, or 256 for AES.
     * We've wrapped all the four elements discussed above into a PBEKeySpec object.
     * Next, using the SecretKeyFactory, we get an instance of PBKDF2WithHmacSHA256 algorithm to generate the key.
     * Finally, invoking generateSecret with the PBEKeySpec, we generate a SecretKey based on a human-readable password.
     * </p>
     * @param cipher   {@link String}
     * @param keySize  {@link Integer}
     * @param password {@link Character}
     * @return {@link Key}
     */
    public Key getPasswordBasedKey(String cipher, int keySize, char[] password) throws NoSuchAlgorithmException, InvalidKeySpecException {
        byte[] salt = new byte[100];
        secureRandom.nextBytes(salt);
        if (isValidPassword(password)) {
            throw new PasswordError();
        }
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, 1000, keySize);
        SecretKey pbeKey = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256").generateSecret(pbeKeySpec);
        return new SecretKeySpec(pbeKey.getEncoded(), cipher);
    }

    /**
     * This password is a secret and must be protected. The password guidelines must be followed,
     * such as a minimum length of 8 characters, the use of special characters,
     * the combination of uppercase and lowercase letters, digits, and so on.
     *
     * @param password {@link Character}
     * @return {@link Boolean}
     */
    private boolean isValidPassword(char[] password) {
        return password.length >= 8 && Arrays.toString(password).matches(REGEX_EXPRESSION);
    }
}
